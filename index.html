<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ColorNoise v1.10.5.1</title>

  <!-- Cache control -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#0b0f18">

  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body {
      margin: 0; 
      min-height: 100vh;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: radial-gradient(1200px 800px at 20% 10%, rgba(120,120,255,.22), transparent 60%),
                  radial-gradient(1000px 700px at 80% 90%, rgba(0,255,200,.12), transparent 60%),
                  linear-gradient(135deg, #0b0f18, #070a10);
      background-attachment: fixed;
      color: #e8eefc;
    }
    
    /* Fixed header with player and timer */
    .fixedHeader {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      background: rgba(11, 15, 24, 0.98);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(255,255,255,0.1);
      padding: 12px 16px;
    }
    
    .headerTop {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .headerLeft {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    
    .logo {
      font-size: 20px;
      font-weight: 800;
      letter-spacing: -0.02em;
    }
    .logo a { color: inherit; text-decoration: none; }
    .version {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 6px;
      background: rgba(255,255,255,0.1);
      color: rgba(232,238,252,0.7);
      margin-left: 6px;
    }
    .byline {
      font-size: 11px;
      color: rgba(232,238,252,0.6);
    }
    .sourceStatus {
      font-size: 11px;
      color: rgba(232,238,252,0.6);
    }
    .sourceStatus .dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 4px;
      vertical-align: middle;
    }
    .sourceStatus .dot.up { background: #2ecc71; box-shadow: 0 0 4px #2ecc71; }
    .sourceStatus .dot.down { background: #e74c3c; box-shadow: 0 0 4px #e74c3c; }
    .sourceStatus .dot.checking { background: #f39c12; box-shadow: 0 0 4px #f39c12; }
    
    /* Compact player */
    .playerRow {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .nowPlaying {
      font-size: 14px;
      color: rgba(232,238,252,0.9);
      font-weight: 600;
    }
    audio {
      width: 100%;
      height: 40px;
    }
    
    /* Compact timer */
    .timerRow {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.08);
    }
    .timerLabel {
      font-size: 11px;
      color: rgba(232,238,252,0.6);
    }
    .timerDisplay {
      font-size: 16px;
      font-weight: 800;
      font-variant-numeric: tabular-nums;
      min-width: 60px;
    }
    .timerDisplay.off { opacity: 0.4; }
    .timerControls {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .timerBtn {
      width: 28px; height: 28px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.1);
      color: #fff;
      font-size: 14px;
      font-weight: 700;
      display: grid;
      place-items: center;
      cursor: pointer;
      user-select: none;
    }
    .timerBtn:active { background: rgba(255,255,255,0.2); }
    .timerNum {
      font-size: 14px;
      font-weight: 700;
      min-width: 20px;
      text-align: center;
    }
    .timerStartBtn {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.1);
      color: #e8eefc;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
      margin-left: auto;
    }
    .timerStartBtn:active { background: rgba(255,255,255,0.2); }
    
    /* Fixed favorites panel - always visible below header */
    .stickyFavorites {
      position: fixed;
      top: 175px; /* below header - will be set by JS */
      left: 0;
      right: 0;
      z-index: 90;
      background: #0b0f18;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      padding: 12px 16px;
    }
    .stickyFavorites .sectionTitle {
      margin-top: 0;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
    }
    .stickyFavorites .grid {
      max-width: 800px;
      margin: 0 auto;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    
    /* Compact favorite tiles - just clickable buttons */
    .favTile {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(255,255,255,0.08);
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s;
    }
    .favTile:hover {
      background: rgba(255,255,255,0.12);
    }
    .favTile.active {
      background: rgba(120,180,255,0.25);
      border-color: rgba(120,180,255,0.5);
    }
    .favTile .colorDot {
      width: 10px;
      height: 10px;
    }
    .favTile .name {
      font-size: 13px;
      font-weight: 600;
    }
    .favTile .headphoneIcon {
      font-size: 10px;
      opacity: 0.6;
      margin-left: 2px;
    }
    
    /* Scrollable content - padding for fixed header */
    .content {
      padding: 16px;
      padding-top: 190px; /* space for fixed header */
      max-width: 800px;
      margin: 0 auto;
    }
    .content.with-favorites {
      padding-top: 280px; /* extra space when favorites visible */
    }
    
    .sectionTitle {
      font-size: 13px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: rgba(232,238,252,0.6);
      margin: 16px 0 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      user-select: none;
    }
    .sectionTitle:first-child { margin-top: 0; }
    .sectionTitle:hover { color: rgba(232,238,252,0.8); }
    .collapseBtn {
      font-size: 12px;
      opacity: 0.6;
      transition: transform 0.2s;
    }
    .sectionTitle.collapsed .collapseBtn {
      transform: rotate(-90deg);
    }
    .sectionNote {
      font-size: 10px;
      font-weight: 400;
      text-transform: none;
      letter-spacing: 0;
      opacity: 0.7;
    }
    
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
      gap: 10px;
    }
    .grid.collapsed {
      display: none;
    }
    
    .tile {
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.1);
      background: rgba(0,0,0,0.25);
      padding: 12px;
    }
    .tileTop {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .colorDot {
      width: 12px; height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
      box-shadow: 0 0 6px currentColor;
    }
    .name {
      font-size: 15px;
      font-weight: 700;
      flex: 1;
    }
    .favBtn {
      font-size: 16px;
      cursor: pointer;
      opacity: 0.4;
      transition: opacity 0.2s;
    }
    .favBtn:hover, .favBtn.active { opacity: 1; }
    .playBtn {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(255,255,255,0.08);
      color: #e8eefc;
      font-size: 12px;
      font-weight: 700;
      cursor: pointer;
    }
    .playBtn:hover { background: rgba(255,255,255,0.12); }
    .playBtn.active {
      background: rgba(120,180,255,0.25);
      border-color: rgba(120,180,255,0.5);
    }
    .desc {
      font-size: 12px;
      color: rgba(232,238,252,0.6);
      margin-top: 6px;
      line-height: 1.4;
    }
    

    
    /* Favorites edit controls */
    .favHeaderRow {
      display: flex;
      align-items: center;
      gap: 10px;
      width: 100%;
    }
    .favHeaderTitle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      flex: 1;
    }
    .favEditBtn {
      margin-left: auto;
      font-size: 11px;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      padding: 4px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: rgba(232,238,252,0.85);
      cursor: pointer;
      user-select: none;
    }
    .favEditBtn:hover { background: rgba(255,255,255,0.12); }
    .favEditBtn:active { background: rgba(255,255,255,0.18); }

    .favTile .favActions {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      margin-left: auto;
    }
    .favTile .miniBtn {
      width: 22px;
      height: 22px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.2);
      color: rgba(232,238,252,0.9);
      font-size: 12px;
      font-weight: 800;
      display: grid;
      place-items: center;
      cursor: pointer;
      user-select: none;
    }
    .favTile .miniBtn:hover { background: rgba(255,255,255,0.10); }
    .favTile .miniBtn:active { background: rgba(255,255,255,0.16); }
    .favTile.editing { cursor: default; }

    
    /* Settings button */
    .settingsBtn {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 250;
      width: 36px;
      height: 36px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: rgba(232,238,252,0.9);
      font-size: 16px;
      font-weight: 800;
      cursor: pointer;
      user-select: none;
    }
    .settingsBtn:hover { background: rgba(255,255,255,0.12); }
    .settingsBtn:active { background: rgba(255,255,255,0.18); }

    /* Settings drawer */
    .settingsOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      z-index: 200;
      display: grid;
      place-items: end center;
      padding: 12px;
    }
    .settingsPanel {
      width: min(760px, 100%);
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(11, 15, 24, 0.98);
      backdrop-filter: blur(14px);
      box-shadow: 0 18px 60px rgba(0,0,0,0.45);
      overflow: hidden;
    }
    .settingsHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }
    .settingsTitle {
      font-size: 14px;
      font-weight: 900;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: rgba(232,238,252,0.85);
    }
    .settingsClose {
      width: 34px;
      height: 34px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: rgba(232,238,252,0.9);
      font-size: 14px;
      font-weight: 900;
      cursor: pointer;
    }
    .settingsBody {
      padding: 14px 16px 16px;
      display: grid;
      gap: 12px;
    }
    .settingRow {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.06);
    }
    .settingLabel {
      flex: 1;
      font-size: 13px;
      font-weight: 700;
      color: rgba(232,238,252,0.88);
    }
    .settingControl {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 240px;
      justify-content: flex-end;
    }
    .settingControl input[type="range"] {
      width: 170px;
    }
    .settingValue {
      font-variant-numeric: tabular-nums;
      font-size: 12px;
      font-weight: 800;
      min-width: 56px;
      text-align: right;
      color: rgba(232,238,252,0.75);
    }
    .settingsHint {
      font-size: 11px;
      color: rgba(232,238,252,0.6);
      padding: 2px 2px 0;
    }

    /* Toggle switch */
    .switch { position: relative; display: inline-block; width: 44px; height: 26px; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .switch .slider {
      position: absolute;
      cursor: pointer;
      inset: 0;
      background: rgba(255,255,255,0.18);
      border: 1px solid rgba(255,255,255,0.18);
      transition: .2s;
      border-radius: 999px;
    }
    .switch .slider:before {
      position: absolute;
      content: "";
      height: 20px;
      width: 20px;
      left: 3px;
      top: 2px;
      background: rgba(232,238,252,0.92);
      transition: .2s;
      border-radius: 50%;
    }
    .switch input:checked + .slider {
      background: rgba(120,180,255,0.35);
      border-color: rgba(120,180,255,0.5);
    }
    .switch input:checked + .slider:before {
      transform: translateX(18px);
    }


    .miniCtlBtn {
      width: 34px;
      height: 28px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: rgba(232,238,252,0.9);
      font-size: 14px;
      font-weight: 900;
      cursor: pointer;
      user-select: none;
    }
    .miniCtlBtn:hover { background: rgba(255,255,255,0.12); }
    .miniCtlBtn:active { background: rgba(255,255,255,0.18); }
    .playerEl.hidden { display: none; }

    
    /* Main-screen master volume */
    .mainVolRow {
      margin-top: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
    }
    .mainVolLabel {
      font-size: 12px;
      font-weight: 800;
      color: rgba(232,238,252,0.78);
      min-width: 56px;
    }
    #mainMasterVol {
      flex: 1;
    }
    .mainVolVal {
      font-variant-numeric: tabular-nums;
      font-size: 12px;
      font-weight: 900;
      color: rgba(232,238,252,0.75);
      min-width: 48px;
      text-align: right;
    }
    .reloadIndicator {
      color: #f39c12;
      font-size: 11px;
      font-weight: 600;
      margin-left: 6px;
    }
    .iosNote {
      color: #e74c3c;
      font-size: 11px;
      font-weight: 600;
      margin-left: 6px;
    }
    .settingRow.disabled {
      opacity: 0.5;
      pointer-events: none;
    }
    .hidden { display: none !important; }
  </style>
</head>

<body>

  <!-- Fixed header with player and timer -->
  <div class="fixedHeader">
    <div class="headerTop">
      <div class="headerLeft">
        <div class="logo">
          <a href="https://en.wikipedia.org/wiki/Colors_of_noise" target="_blank">Color Noise â†—</a>
          <span class="version">v1.10.12</span>
        </div>
        <div class="byline">by AboveAverageJoe</div>
        <div class="sourceStatus" id="sourceStatus">
          <span class="dot checking"></span>Sound engine: initializing...
        </div>
      </div>
      <div class="headerRight">
        <button class="settingsBtn" id="settingsBtn" title="Settings" aria-label="Settings">âš™ï¸Ž</button>
      </div>
    </div>
    
    <div class="playerRow">
      <div class="nowPlaying" id="nowPlayingTrack">Select a sound below</div>
      <audio id="playerA" class="playerEl" controls playsinline preload="auto" loop crossorigin="anonymous"></audio>
      <audio id="playerB" class="playerEl hidden" controls playsinline preload="auto" loop crossorigin="anonymous"></audio>

      <!-- Master volume (optional) -->
      <div class="mainVolRow" id="mainVolRow">
        <div class="mainVolLabel">Volume</div>
        <input type="range" id="mainMasterVol" min="0" max="1" step="0.01" aria-label="Master volume">
        <div class="mainVolVal" id="mainMasterVolVal">100%</div>
      </div>

      <!-- Per-track volume adjustment (shown only when enabled) -->
      <div class="mainVolRow hidden" id="perTrackRow">
        <div class="mainVolLabel">Sound-specific normalization</div>
        <div style="margin-left:auto; display:flex; align-items:center; gap:10px;">
          <button class="miniCtlBtn" id="mainTrimDown" title="Make this sound quieter">âˆ’</button>
          <div class="settingValue" id="mainTrimVal" style="min-width:56px; text-align:center;">0 dB</div>
          <button class="miniCtlBtn" id="mainTrimUp" title="Make this sound louder">+</button>
          <button class="miniCtlBtn" id="mainTrimReset" title="Reset this sound">â†º</button>
        </div>
      </div>


    </div>
    
    <div class="timerRow">
      <div class="timerLabel">Sleep</div>
      <div class="timerDisplay off" id="timerDisplay">0:00</div>
      <div class="timerControls">
        <div class="timerBtn" id="hMinus">âˆ’</div>
        <div class="timerNum" id="hours">0</div>
        <div class="timerLabel">h</div>
        <div class="timerBtn" id="hPlus">+</div>
        <div class="timerBtn" id="mMinus">âˆ’</div>
        <div class="timerNum" id="mins">0</div>
        <div class="timerLabel">m</div>
        <div class="timerBtn" id="mPlus">+</div>
      </div>
      <div class="timerStartBtn" id="toggleTimer">Start</div>
    </div>
  </div>

  <!-- Settings drawer -->
  <div class="settingsOverlay hidden" id="settingsOverlay" aria-hidden="true">
    <div class="settingsPanel" role="dialog" aria-modal="true" aria-label="Settings">
      <div class="settingsHeader">
        <div class="settingsTitle">Settings</div>
        <button class="settingsClose" id="settingsClose" aria-label="Close settings">âœ•</button>
      </div>

      <div class="settingsBody">
        <div class="settingRow">
          <div class="settingLabel">Crossfade on track switch</div>
          <label class="switch">
            <input type="checkbox" id="enableCrossfade">
            <span class="slider"></span>
          </label>
        </div>
        <div class="settingRow">
          <div class="settingLabel">Crossfade duration</div>
          <div class="settingControl">
            <input type="range" id="crossfadeSec" min="0" max="6" step="0.5">
            <div class="settingValue" id="crossfadeSecVal"></div>
          </div>
        </div>

        <div class="settingRow">
          <div class="settingLabel">Fade out when sleep timer ends</div>
          <label class="switch">
            <input type="checkbox" id="enableFadeOut">
            <span class="slider"></span>
          </label>
        </div>
        <div class="settingRow">
          <div class="settingLabel">Fade-out duration</div>
          <div class="settingControl">
            <input type="range" id="fadeOutSec" min="0" max="12" step="0.5">
            <div class="settingValue" id="fadeOutSecVal"></div>
          </div>
        </div>

        <div class="settingRow" id="masterVolRow">
          <div class="settingLabel">Master volume <span class="iosNote hidden" id="masterVolIosNote">(not available on iOS)</span></div>
          <div class="settingControl">
            <input type="range" id="masterVol" min="0" max="1" step="0.01">
            <div class="settingValue" id="masterVolVal"></div>
          </div>
        </div>


        <div class="settingRow">
          <div class="settingLabel">Show sleep timer</div>
          <label class="switch">
            <input type="checkbox" id="showSleepTimer">
            <span class="slider"></span>
          </label>
        </div>


        <div class="settingRow" id="showMainVolumeRow">
          <div class="settingLabel">Show master volume on main screen <span class="iosNote hidden" id="showMainVolumeIosNote">(not available on iOS)</span></div>
          <label class="switch">
            <input type="checkbox" id="showMainVolume">
            <span class="slider"></span>
          </label>
        </div>

        <div class="settingRow" id="normalizeRow">
          <div class="settingLabel">Normalize track loudness <span class="reloadIndicator hidden" id="reloadIndicator">(reload required)</span> <span class="iosNote hidden" id="normalizeIosNote">(not available on iOS)</span></div>
          <label class="switch">
            <input type="checkbox" id="enableNormalize">
            <span class="slider"></span>
          </label>
        </div>

        <div class="settingRow" id="showPerTrackRow">
          <div class="settingLabel">Show sound-specific controls <span class="iosNote hidden" id="showPerTrackIosNote">(not available on iOS)</span></div>
          <label class="switch">
            <input type="checkbox" id="showPerTrackPanel">
            <span class="slider"></span>
          </label>
        </div>

        <div class="settingsHint">
          Tip: iOS may require one tap on â–¶ï¸Ž before audio starts.
        </div>
      </div>
    </div>
  </div>

  <!-- Sticky favorites - outside content for proper sticky behavior -->
  <div id="favoritesSection" class="stickyFavorites hidden">
    <div class="sectionTitle" id="favHeader">
      <div class="favHeaderRow">
        <span class="favHeaderTitle">
          <span class="collapseBtn">â–¼</span>
          â˜… Favorites
        </span>
        <span class="favEditBtn" id="favEditBtn">Edit</span>
      </div>
    </div>
    <div class="grid" id="favGrid"></div>
  </div>

  <!-- Scrollable stations -->
  <div class="content">
    <div class="sectionTitle" data-section="core">
      <span class="collapseBtn">â–¼</span>
      Core Colors
    </div>
    <div class="grid" id="coreGrid"></div>
    
    <div class="sectionTitle" data-section="blends">
      <span class="collapseBtn">â–¼</span>
      Nature + Noise Blends
    </div>
    <div class="grid" id="blendsGrid"></div>
    
    <div class="sectionTitle" data-section="binaural">
      <span class="collapseBtn">â–¼</span>
      Binaural Beats
      <span class="sectionNote">ðŸŽ§ headphones required</span>
    </div>
    <div class="grid" id="binauralGrid"></div>
    
    <div class="sectionTitle" data-section="nature">
      <span class="collapseBtn">â–¼</span>
      Nature Sounds
    </div>
    <div class="grid" id="natureGrid"></div>
    
    <div class="sectionTitle" data-section="mechanical">
      <span class="collapseBtn">â–¼</span>
      ðŸš€ Mechanical / Sci-Fi
    </div>
    <div class="grid" id="mechanicalGrid"></div>
  </div>

<script>
(() => {
  const COLORS = {
    white: "#ffffff",
    pink: "#ff69b4",
    brown: "#8b4513",
    blue: "#4a90d9",
    green: "#2ecc71",
    red: "#cd5c5c",
    purple: "#9b59b6",
    orange: "#e67e22",
    gray: "#95a5a6",
    cyan: "#00bcd4"
  };

  const SOURCES_CORE = [
    {
      key: "white",
      name: "White",
      color: COLORS.white,
      desc: "Broad spectrum hiss. Best for masking sudden noises. 1 hour.",
      url: "https://archive.org/download/24-hours-lectrofan-sound-and-white-noise-river-128/1%20hour%20lectrofan%20sound%20and%20white%20noise%20river%20128.mp3"
    },
    {
      key: "pink",
      name: "Pink",
      color: COLORS.pink,
      desc: "Smoother than white. Feels like rainfall. 1 hour.",
      url: "https://archive.org/download/classical-music-mixed-with-pink-noise-for-sleep-and-relax_202105/Soothing%20Deep%20Pink%20Noise%20%201%20Hour.mp3"
    },
    {
      key: "brown",
      name: "Brown",
      color: COLORS.brown,
      desc: "Deep bass-heavy rumble. Very calming. 1 hour.",
      url: "https://archive.org/download/1-hour-brown-noise-and-flowing-water-320/1%20hour%20Brown%20Noise%20and%20Flowing%20River%20flac.mp3"
    },
    {
      key: "blue",
      name: "Blue",
      color: COLORS.blue,
      desc: "Higher frequencies. Masks high-pitched sounds. 1 hour.",
      url: "https://archive.org/download/1-hour-texas-river-rapids-and-deep-blue-noise-320/1%20hour%20texas%20river%20rapids%20and%20deep%20blue%20noise%20320.mp3"
    },
    {
      key: "green_pure",
      name: "Green (Pure)",
      color: COLORS.green,
      desc: "Mid-frequency, nature-like. Stress and anxiety relief. 4 hours.",
      url: "https://archive.org/download/green-noise/Green%20Noise.mp3"
    },
    {
      key: "red",
      name: "Red (Deep Brown)",
      color: COLORS.red,
      desc: "Even deeper than brown. Extremely relaxing. 1 hour.",
      url: "https://archive.org/download/red-noise_202207/red%20noise.mp3"
    }
  ];

  const SOURCES_BLENDS = [
    {
      key: "blue_waterfall",
      name: "Blue + Waterfall",
      color: COLORS.blue,
      desc: "Blue noise with waterfall. 1 hour.",
      url: "https://archive.org/download/clip-waterfall-relaxing-sleep-rem-asmr/1%20hour%20waterfall%20relaxing%20sleep%20blue%20noise%20rem%20asmr%20320.mp3"
    },
    {
      key: "red_waterfall",
      name: "Red + Waterfall",
      color: COLORS.red,
      desc: "Deep red/brown with waterfall. 1 hour.",
      url: "https://archive.org/download/clip-waterfall-relaxing-sleep-rem-asmr/1%20hour%20waterfall%20relaxing%20rem%20red%20noise%20sleep%20320.mp3"
    },
    {
      key: "brown_river",
      name: "Brown + River",
      color: COLORS.brown,
      desc: "Brown noise with peaceful river. 1 hour.",
      url: "https://archive.org/download/24-hours-peaceful-river-and-brown-noise-vbr/1%20hour%20v3%20river%20and%20brown%20noise%20vbr.mp3"
    },
    {
      key: "brown_rain",
      name: "Brown + Rain",
      color: COLORS.brown,
      desc: "Brown noise with rain. 1 hour.",
      url: "https://archive.org/download/red-noise_202207/1-rain%20and%20brown%20noise%20-%20320%20-%201%20hour.mp3"
    },
    {
      key: "brown_stream",
      name: "Brown + Mountain Stream",
      color: COLORS.brown,
      desc: "Brown noise with stream and rain. 1 hour.",
      url: "https://archive.org/download/1-hour-mountain-stream-doubled-and-brown-noise-flac/1%20hour%20mountain%20stream%20-%20rain%20shower%20-%20brown%20noise%20v2%20320.mp3"
    },
    {
      key: "white_roaring",
      name: "White + Roaring Waterfall",
      color: COLORS.white,
      desc: "White noise with powerful waterfall. 10 hours.",
      url: "https://archive.org/download/1-fan-4-1-hour-flac/Roaring%20Waterfall%20White%20Noise%2010%20hours.mp3"
    },
    {
      key: "brown_terraced",
      name: "Brown + Terraced Waterfall",
      color: COLORS.brown,
      desc: "Brown noise with cascading water. 10 hours.",
      url: "https://archive.org/download/1-fan-4-1-hour-flac/10%20hours%20terraced%20waterfall%20brown%20noise%20sound%20128.mp3"
    },
    {
      key: "pink_reading",
      name: "Pink for Focus",
      color: COLORS.pink,
      desc: "Pink noise for reading/concentration. 1 hour.",
      url: "https://archive.org/download/classical-music-mixed-with-pink-noise-for-sleep-and-relax_202105/Pink%20Noise%20Focus%20on%20Reading%20Without%20DistractionsRuido%20RosaLeer%20Sin%20Distracciones.mp3"
    },
    {
      key: "green_stream",
      name: "Green + Stream",
      color: COLORS.green,
      desc: "Mountain stream â€” nature's green noise. 1 hour.",
      url: "https://archive.org/download/10-hours-white-noise-river-mountain-stream-doubled-320/1%20Hour%20Calming%20Mountain%20Stream.mp3"
    },
    {
      key: "alpha_brown",
      name: "Alpha + Brown Noise",
      color: COLORS.purple,
      desc: "Alpha waves blended with brown noise. 1 hour.",
      url: "https://archive.org/download/10-hours-alpha-river-and-brown-noise-flac/1%20hour%20alpha%20river%20and%20brown%20noise%20v1%20flac.mp3"
    },
    {
      key: "turquoise_stream",
      name: "Turquoise Mountain Stream",
      color: COLORS.cyan,
      desc: "Calming turquoise water, mountain stream. 10 hours.",
      url: "https://archive.org/download/10-hours-alpha-river-and-brown-noise-flac/10%20hours%20Calming%20Turquoise%20Water%2C%20Mountain%20Stream%20vbr.mp3"
    },
    {
      key: "hot_tub",
      name: "Hot Tub / Jacuzzi",
      color: COLORS.cyan,
      desc: "Smooth hot tub bubbling. 1 hour.",
      url: "https://archive.org/download/10-hours-alpha-river-and-brown-noise-flac/1%20hour%20smooth%20hot%20tub%20128.mp3"
    }
  ];

  const SOURCES_BINAURAL = [
    {
      key: "alpha_focus",
      name: "Alpha (12 Hz) - Focus",
      color: COLORS.purple,
      desc: "Promotes alert relaxation and focus. Use headphones. 1 hour.",
      url: "https://archive.org/download/RestorativeSleepMusicBinauralBeatsSleepInTheClouds432Hz/Pure%20Alpha%20Waves%20Binaural%20Beats%20%2812%20Hz%29%20%201H.mp3",
      headphones: true
    },
    {
      key: "theta_meditation",
      name: "Theta (4 Hz) - Meditation",
      color: COLORS.purple,
      desc: "Deep meditation and creativity. Use headphones. 1 hour.",
      url: "https://archive.org/download/RestorativeSleepMusicBinauralBeatsSleepInTheClouds432Hz/Pure%20Theta%20Waves%20%284%20Hz%29%20%20Deep%20Meditation%20-%201hr%20Binaural%20Beats.mp3",
      headphones: true
    },
    {
      key: "delta_sleep",
      name: "Delta (0.5 Hz) - Deep Sleep",
      color: COLORS.purple,
      desc: "Deepest relaxation and sleep. Use headphones. 1 hour.",
      url: "https://archive.org/download/RestorativeSleepMusicBinauralBeatsSleepInTheClouds432Hz/Pure%20Delta%20Waves%20%280.5%20Hz%20Binaural%20Beats%29%20%201H.mp3",
      headphones: true
    },
    {
      key: "gamma_40hz",
      name: "Gamma (40 Hz) - Peak Focus",
      color: COLORS.purple,
      desc: "40 Hz gamma for focus, calmness, happiness. Use headphones. 1 hour.",
      url: "https://archive.org/download/study-music-alpha-waves-studying-music-concentration-music-focus-music-for-work-brain-power/Gamma%20Brain%20Waves%20Meditation%2040%20Hz%20frequency%201%20Hr%20Producing%20Focus%20Calmness%20Happiness.mp3",
      headphones: true
    },
    {
      key: "anxiety_relief",
      name: "Anxiety Relief",
      color: COLORS.purple,
      desc: "Release stress, worry, overthinking. Use headphones. 1 hour.",
      url: "https://archive.org/download/study-music-alpha-waves-studying-music-concentration-music-focus-music-for-work-brain-power/Anxiety%20Relief%20%20Release%20Stress%20Worry%20Overthinking%20%20Binaural%20Beats%20%20Meditation%20Music.mp3",
      headphones: true
    },
    {
      key: "stay_awake",
      name: "Stay Awake - Isochronic",
      color: COLORS.purple,
      desc: "Isochronic tones for staying awake and alert. 30 min.",
      url: "https://archive.org/download/study-music-alpha-waves-studying-music-concentration-music-focus-music-for-work-brain-power/Staying%20Awake%20%20Isochronic%20Tones%20%20Brainwave%20Entrainment%20Meditation.mp3",
      headphones: true
    },
    {
      key: "beta_30hz",
      name: "Beta (30 Hz) - Alertness",
      color: COLORS.purple,
      desc: "Pure 30 Hz beta binaural for alertness. Use headphones. 30 min.",
      url: "https://archive.org/download/study-music-alpha-waves-studying-music-concentration-music-focus-music-for-work-brain-power/30%20Hz%20Pure%20BINAURAL%20Beat%20%20BETA%20Waves%2070Hz%20Base%20Frequency%20%20Ondas%20Beta%20100.mp3",
      headphones: true
    },
    {
      key: "deep_alpha_15min",
      name: "Deep Alpha - Quick",
      color: COLORS.purple,
      desc: "Deep alpha binaural meditation. Use headphones. 15 min.",
      url: "https://archive.org/download/study-music-alpha-waves-studying-music-concentration-music-focus-music-for-work-brain-power/Deep%20Alpha%20Binaural%20Beats%2015%20min%20Meditation.mp3",
      headphones: true
    },
    {
      key: "theta_432hz",
      name: "Theta + 432 Hz - DMT",
      color: COLORS.purple,
      desc: "Theta brainwaves with 432 Hz and 60 Hz. Use headphones. 1 hour.",
      url: "https://archive.org/download/study-music-alpha-waves-studying-music-concentration-music-focus-music-for-work-brain-power/Theta%20Brainwaves%20%20432hz%20%208hz%20%2060hz%20%20%20Pineal%20Gland%20DMT%20Music.mp3",
      headphones: true
    }
  ];

  const SOURCES_NATURE = [
    {
      key: "thunder_beach",
      name: "Thunder + Rain + Beach",
      color: COLORS.gray,
      desc: "Very low rumbling thunder with rain and waves. 8 hours.",
      url: "https://archive.org/download/relaxingsounds/Thunder%201%208h%20VeryLowRumbling%2CRain%2CWaves-Beach.mp3"
    },
    {
      key: "ocean_night",
      name: "Ocean Waves (Night)",
      color: COLORS.blue,
      desc: "Beach waves from sunset into night. 10 hours.",
      url: "https://archive.org/download/relaxingsounds/Waves%201%2010h%20Beach-Sunset%20into%20Night.mp3"
    },
    {
      key: "rain_medium",
      name: "Rain (Medium)",
      color: COLORS.gray,
      desc: "Medium rain with low gentle thunder. 10 hours.",
      url: "https://archive.org/download/relaxingsounds/Rain%202%20%28Med.%2B%29%2010h%20LowGentleThunder%2C%20Downpour.mp3"
    },
    {
      key: "campfire_crickets",
      name: "Campfire + Crickets",
      color: COLORS.orange,
      desc: "Crackling campfire with crickets and gentle water. 10 hours.",
      url: "https://archive.org/download/relaxingsounds/FIRE%201%2010h%20CracklingCampfire%2CCrickets%2CRainOrRiver-Night.mp3"
    },
    {
      key: "rain_tent",
      name: "Rain on Tent Canvas",
      color: COLORS.gray,
      desc: "Light rain on tent canvas. Medium/gentle, no thunder. 10 hours.",
      url: "https://archive.org/download/relaxingsounds/Rain%206%20%28Light%29%2010h%20on%20Tent%20Canvas%2C%28MediumGentle%29-no%20thunder.mp3"
    },
    {
      key: "rainforest",
      name: "Rainforest",
      color: COLORS.green,
      desc: "Bubbling river, falls, birds, insects, animals. South America. 5 hours.",
      url: "https://archive.org/download/relaxingsounds/Rainforest%205h%20Bubbling%20River%20Falls(gentle)%2CBirds%2CInsects%2CAnimals-Daytime%2CSouth%20America.mp3"
    }
  ];

  const SOURCES_MECHANICAL = [
    {
      key: "box_fan",
      name: "Box Fan",
      color: COLORS.white,
      desc: "Strong box fan. Classic sleep sound. 10 hours.",
      url: "https://archive.org/download/relaxingsounds/FAN%201%2010h%20Strong%20Box%20Fan.mp3"
    },
    {
      key: "oscillating_fan",
      name: "Oscillating Fan",
      color: COLORS.white,
      desc: "Gentle oscillating fan. 10 hours.",
      url: "https://archive.org/download/relaxingsounds/FAN%202%2010h%20Gentle%2COscillating%20Fan.mp3"
    },
    {
      key: "stereo_fan",
      name: "Stereo Fan",
      color: COLORS.white,
      desc: "Oscillating stereo fan with panning effect. 9 hours.",
      url: "https://archive.org/download/relaxingsounds/FAN%203%209h%20OscillatingStereoFan.mp3"
    },
    {
      key: "train_horns",
      name: "Train (with Horns)",
      color: COLORS.brown,
      desc: "Low train rumble with horn and crossing bells. 10 hours.",
      url: "https://archive.org/download/relaxingsounds/Train%201%2010h%20LowRumble%2BHorn%2CCrossingBells.mp3"
    },
    {
      key: "train_quiet",
      name: "Train (Quiet)",
      color: COLORS.brown,
      desc: "Medium-lite train rumble. No horns or bells. 9 hours.",
      url: "https://archive.org/download/relaxingsounds/Train%203%209h%20Med.LiteRumble-NoHornsOrBells.mp3"
    },
    {
      key: "film_projector",
      name: "Film Projector",
      color: COLORS.orange,
      desc: "Gentle film projector clicking and whirring. 9 hours.",
      url: "https://archive.org/download/relaxingsounds/Film%20Projector%209h%20gentle%20v2.mp3"
    },
    {
      key: "starship_engine",
      name: "Starship Engine",
      color: COLORS.blue,
      desc: "Star Trek TNG warp engine ambient drone. Sleep in space. 24 hours.",
      url: "https://archive.org/download/AmbientEngineNoiseidlingFor24Hrs_614/AmbientEngineNoiseidlingFor24Hrs.mp3"
    }
  ];

  const ALL_SOURCES = [...SOURCES_CORE, ...SOURCES_BLENDS, ...SOURCES_BINAURAL, ...SOURCES_NATURE, ...SOURCES_MECHANICAL];

  // LocalStorage keys
  const LS_FAV = "colorNoiseFavorites";
  const LS_COL = "colorNoiseCollapsed";
  const LS_LAST_KEY = "colorNoiseLastKey";
  const LS_LAST_NAME = "colorNoiseLastName";
  const LS_SETTINGS = "colorNoiseSettings_v1";
  const LS_TRIMS = "colorNoiseTrackTrims_v1";

  // Load state
  let favorites = JSON.parse(localStorage.getItem(LS_FAV) || "[]");
  let collapsedSections = JSON.parse(localStorage.getItem(LS_COL) || '{"core":false,"blends":true,"binaural":true,"nature":true,"mechanical":true}');
  let favoritesEditMode = false;

  // Settings (with defaults)
  let settings = (() => {
    const defaults = {
      enableCrossfade: true,
      crossfadeSec: 1.5,
      enableFadeOut: true,
      fadeOutSec: 2.0,
      masterVol: 1.0,
      showSleepTimer: true,
      showMainVolume: true,
      enableNormalize: true
    };
    try {
      const saved = JSON.parse(localStorage.getItem(LS_SETTINGS) || "null");
      return { ...defaults, ...(saved || {}) };
    } catch {
      return defaults;
    }
  })();


  // iOS background/lock-screen: WebAudio often gets suspended, causing silent playback.
  // We use a simple <audio>-only path on iPhone/iPad to keep sound audible when locked/minimized.
  const IS_IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);

  function setMediaSession(title) {
    if (!("mediaSession" in navigator)) return;
    try {
      const iconEl = document.querySelector('link[rel~="icon"]');
      const iconHref = iconEl ? iconEl.href : "";
      navigator.mediaSession.metadata = new MediaMetadata({
        title: title || "Color Noise",
        artist: "ColorNoise",
        album: "ColorNoise Feeds",
        artwork: iconHref ? [{ src: iconHref }] : []
      });
    } catch {}
  }

  // Per-track trim (dB) storage for loudness normalization
  let trackTrims = (() => {
    try { return JSON.parse(localStorage.getItem(LS_TRIMS) || "{}"); } catch { return {}; }
  })();

  function saveTrackTrims() {
    try { localStorage.setItem(LS_TRIMS, JSON.stringify(trackTrims)); } catch {}
  }

  function getTrimDb(key) {
    const v = Number(trackTrims[key] ?? 0);
    if (!isFinite(v)) return 0;
    return Math.max(-18, Math.min(18, v));
  }

  function setTrimDb(key, db) {
    if (!key) return;
    const v = Math.max(-18, Math.min(18, Number(db)));
    trackTrims[key] = v;
    saveTrackTrims();
  }


  function applyPerTrackToElement(player, key) {
    try {
      const base = (settings.masterVol ?? 1);
      const g = dbToGain(getTrimDb(key));
      player.volume = Math.max(0, Math.min(1, base * g));
    } catch {}
  }

  function dbToGain(db) {
    return Math.pow(10, db / 20);
  }

  function saveSettings() {
    try { localStorage.setItem(LS_SETTINGS, JSON.stringify(settings)); } catch {}
  }

  // Elements
  const playerA = document.getElementById("playerA");
  const playerB = document.getElementById("playerB");
  const players = [playerA, playerB];

  const nowPlayingTrack = document.getElementById("nowPlayingTrack");
  const favoritesSection = document.getElementById("favoritesSection");
  const favGrid = document.getElementById("favGrid");

  const timerDisplay = document.getElementById("timerDisplay");
  const toggleTimerBtn = document.getElementById("toggleTimer");
  const hoursEl = document.getElementById("hours");
  const minsEl = document.getElementById("mins");

  // Settings drawer elements
  const settingsBtn = document.getElementById("settingsBtn");
  const settingsOverlay = document.getElementById("settingsOverlay");
  const settingsClose = document.getElementById("settingsClose");
  const enableCrossfadeEl = document.getElementById("enableCrossfade");
  const crossfadeSecEl = document.getElementById("crossfadeSec");
  const crossfadeSecVal = document.getElementById("crossfadeSecVal");
  const enableFadeOutEl = document.getElementById("enableFadeOut");
  const fadeOutSecEl = document.getElementById("fadeOutSec");
  const fadeOutSecVal = document.getElementById("fadeOutSecVal");
  const masterVolEl = document.getElementById("masterVol");
  const masterVolVal = document.getElementById("masterVolVal");
  const showSleepTimerEl = document.getElementById("showSleepTimer");
  const showMainVolumeEl = document.getElementById("showMainVolume");
  const enableNormalizeEl = document.getElementById("enableNormalize");
  const showPerTrackPanelEl = document.getElementById("showPerTrackPanel");

  const mainVolRow = document.getElementById("mainVolRow");
  const mainMasterVolEl = document.getElementById("mainMasterVol");
  const mainMasterVolVal = document.getElementById("mainMasterVolVal");
  const perTrackRow = document.getElementById("perTrackRow");
  const mainTrimDownEl = document.getElementById("mainTrimDown");
  const mainTrimUpEl = document.getElementById("mainTrimUp");
  const mainTrimResetEl = document.getElementById("mainTrimReset");
  const mainTrimValEl = document.getElementById("mainTrimVal");

  // Active player index
  let activeIdx = 0;
  let currentKey = null;

  function activePlayer() { return players[activeIdx]; }
  function inactivePlayer() { return players[1 - activeIdx]; }

  // WebAudio graph (for fades/crossfades)
  let audioCtx = null;
  let mediaSources = [null, null];
  let gains = [null, null];
  let trimGains = [null, null];
  let compressor = null;
  let masterGain = null;

  function ensureAudioGraph() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // Master gain (volume)
    masterGain = audioCtx.createGain();
    masterGain.gain.value = settings.masterVol;

    // Light compressor (gentle leveling of peaks)
    compressor = audioCtx.createDynamicsCompressor();
    compressor.threshold.value = -24;   // dB
    compressor.knee.value = 18;         // dB
    compressor.ratio.value = 2.0;
    compressor.attack.value = 0.01;     // s
    compressor.release.value = 0.25;    // s

    // Routing: per-player trim -> crossfade gain -> (optional compressor) -> master -> speakers
    const postNode = () => (settings.enableNormalize ? compressor : masterGain);

    // Connect post chain: compressor -> master -> destination OR direct master -> destination
    if (settings.enableNormalize) {
      compressor.connect(masterGain);
    }
    masterGain.connect(audioCtx.destination);

    players.forEach((el, i) => {
      const src = audioCtx.createMediaElementSource(el);

      const trim = audioCtx.createGain();    // per-track trim
      const g = audioCtx.createGain();       // crossfade gain

      trim.gain.value = 1;
      g.gain.value = (i === activeIdx) ? 1 : 0;

      src.connect(trim);
      trim.connect(g);

      if (settings.enableNormalize) {
        g.connect(compressor);
      } else {
        g.connect(masterGain);
      }

      mediaSources[i] = src;
      trimGains[i] = trim;
      gains[i] = g;
    });
  }


  async function resetAudioGraph() {
    // Stop audio and rebuild the WebAudio graph on next play (needed when toggling normalization).
    try { activePlayer().pause(); } catch {}
    try { inactivePlayer().pause(); } catch {}
    try {
      if (audioCtx) await audioCtx.close();
    } catch {}
    audioCtx = null;
    mediaSources = [null, null];
    gains = [null, null];
    trimGains = [null, null];
    compressor = null;
    masterGain = null;
  }


  function resumeAudioContext() {
    // iOS/Safari may start suspended.
    if (audioCtx && audioCtx.state === "suspended") {
      audioCtx.resume().catch(() => {});
    }
  }

  function setNowPlaying(text) {
    nowPlayingTrack.textContent = text;
  }

  function persistNowPlaying(key, name) {
    try {
      localStorage.setItem(LS_LAST_KEY, key || "");
      localStorage.setItem(LS_LAST_NAME, name || "");
    } catch {}
  }

  function saveFavorites() {
    localStorage.setItem(LS_FAV, JSON.stringify(favorites));
  }

  function saveCollapsed() {
    localStorage.setItem(LS_COL, JSON.stringify(collapsedSections));
  }

  function toggleFavorite(key) {
    const idx = favorites.indexOf(key);
    if (idx === -1) favorites.push(key);
    else favorites.splice(idx, 1);
    saveFavorites();
    renderAll();
  }

  function setActive(key) {
    document.querySelectorAll(".playBtn").forEach(b => {
      const isActive = b.dataset.key === key;
      b.classList.toggle("active", isActive);
      if (b.textContent !== "Soon") b.textContent = isActive ? "Playing" : "Play";
    });

    document.querySelectorAll(".favBtn").forEach(b => {
      b.classList.toggle("active", favorites.includes(b.dataset.key));
      b.textContent = favorites.includes(b.dataset.key) ? "â˜…" : "â˜†";
    });

    document.querySelectorAll(".favTile").forEach(t => {
      t.classList.toggle("active", t.dataset.key === key);
    });
  }

  function describeMediaError(err) {
    const code = err?.code;
    switch (code) {
      case 1: return "aborted";
      case 2: return "network error";
      case 3: return "decode error";
      case 4: return "source not supported";
      default: return "unknown error";
    }
  }

  // ---- Fade helpers (WebAudio Gain ramps) ----
  function rampGain(g, from, to, seconds) {
    if (!audioCtx || !g) return;
    const t0 = audioCtx.currentTime;
    g.gain.cancelScheduledValues(t0);
    g.gain.setValueAtTime(from, t0);
    g.gain.linearRampToValueAtTime(to, t0 + Math.max(0, seconds));
  }

  function fadeOutAndStop(playerEl, gainNode, seconds) {
    return new Promise((resolve) => {
      if (!audioCtx || !gainNode || seconds <= 0) {
        try { playerEl.pause(); } catch {}
        resolve();
        return;
      }
      const from = gainNode.gain.value;
      rampGain(gainNode, from, 0, seconds);
      setTimeout(() => {
        try { playerEl.pause(); } catch {}
        resolve();
      }, Math.ceil(seconds * 1000));
    });
  }

  // ---- Core playback logic ----
  async function stopPlayback(reasonText = "Select a sound", useFade = false) {

    if (IS_IOS) {
      const p = activePlayer();
      try { p.pause(); } catch {}
      try { p.removeAttribute("src"); p.load(); } catch {}
      setNowPlaying(reasonText);
      setActive(null);
      currentKey = null;
      persistNowPlaying("", "");
      applyPerTrackVisibility();
      refreshTrimUI();
      return;
    }

    const p = activePlayer();
    ensureAudioGraph();
    resumeAudioContext();

    if (useFade && settings.enableFadeOut) {
      await fadeOutAndStop(p, gains[activeIdx], settings.fadeOutSec);
      // restore gain for future plays
      gains[activeIdx].gain.value = 1;
    } else {
      try { p.pause(); } catch {}
    }

    currentKey = null;
    setActive(null);
    setNowPlaying(reasonText);
    persistNowPlaying("", "");
    applyPerTrackVisibility();
    refreshTrimUI();
  }

  async function playItem(item) {

    if (IS_IOS) {
      const oldP = players[activeIdx];
      const newIdx = 1 - activeIdx;
      const newP = players[newIdx];

      currentKey = item.key;
      persistNowPlaying(item.key, item.name);
      setActive(currentKey);
      setNowPlaying("Loadingâ€¦");
      applyPerTrackVisibility();
      refreshTrimUI();

      try { oldP.pause(); } catch {}
      try { oldP.removeAttribute("src"); oldP.load(); } catch {}

      newP.classList.remove("hidden");
      oldP.classList.add("hidden");

      newP.crossOrigin = "anonymous";
      newP.src = item.url;
      newP.load();
      applyPerTrackToElement(newP, item.key);

      try {
        const pr = newP.play();
        if (pr !== undefined) await pr;
        setNowPlaying(item.name);
        setMediaSession(item.name);
      } catch (e) {
        setNowPlaying(item.name + " (tap â–¶)");
      }

      activeIdx = newIdx;
      setActive(currentKey);
      return;
    }

    if (!item?.url) return;

    ensureAudioGraph();
    resumeAudioContext();

    // Apply per-track trim to the target player (if normalization enabled)
    const applyTrimTo = (playerIndex, key) => {
      if (!settings.enableNormalize) return;
      const db = getTrimDb(key);
      const g = dbToGain(db);
      if (trimGains[playerIndex]) trimGains[playerIndex].gain.value = g;
    };

    // Toggle behavior: if same track is playing, stop.
    if (currentKey === item.key && !activePlayer().paused) {
      await stopPlayback("Select a sound", false);
      return;
    }

    // If nothing playing yet, just load into active player.
    if (!currentKey || activePlayer().paused) {
      currentKey = item.key;
      persistNowPlaying(item.key, item.name);
      setActive(currentKey);
      setNowPlaying("Loadingâ€¦");
      applyPerTrackVisibility();
      refreshTrimUI();

      const p = activePlayer();
      applyTrimTo(activeIdx, item.key);
      p.src = "";
      p.load();
      p.src = item.url;
      p.load();

      const prom = p.play();
      if (prom !== undefined) {
        prom.then(() => setNowPlaying(item.name))
            .catch(() => setNowPlaying(item.name + " (tap â–¶)"));
      }
      return;
    }

    // Switching tracks: stop the old one and start the new one immediately (crossfade if enabled).
    const doCrossfade = settings.enableCrossfade && settings.crossfadeSec > 0;

    const oldIdx = activeIdx;
    const newIdx = 1 - activeIdx;
    const oldP = players[oldIdx];
    const newP = players[newIdx];

    currentKey = item.key;
    persistNowPlaying(item.key, item.name);
    setActive(currentKey);
    setNowPlaying("Loadingâ€¦");
      applyPerTrackVisibility();
      refreshTrimUI();

    // Prepare new player
    newP.classList.remove("hidden");
    oldP.classList.add("hidden");

    newP.src = "";
    newP.load();
    newP.src = item.url;
    newP.load();

    // Initialize gains for the new player
    if (doCrossfade) {
      gains[newIdx].gain.value = 0;
    } else {
      gains[newIdx].gain.value = 1;
    }

    // Try to start the new track right away (within the click gesture)
    let newStarted = false;
    try {
      const pr = newP.play();
      if (pr !== undefined) await pr;
      newStarted = true;
      setNowPlaying(item.name);
    } catch (e) {
      // If autoplay is blocked for any reason, stop the old track anyway and leave the new one ready.
      setNowPlaying(item.name + " (tap â–¶)");
      newStarted = false;
    }

    if (!doCrossfade) {
      // Hard switch: always stop old immediately
      try { oldP.pause(); } catch {}
      activeIdx = newIdx;
      setActive(currentKey);
      return;
    }

    // Crossfade: always fade the old one out. Fade the new one in only if it actually started.
    const sec = settings.crossfadeSec;

    // Fade old down
    rampGain(gains[oldIdx], gains[oldIdx].gain.value, 0, sec);

    // Fade new up (only if started); otherwise keep it silent until user taps â–¶.
    if (newStarted) {
      rampGain(gains[newIdx], gains[newIdx].gain.value, 1, sec);
    } else {
      gains[newIdx].gain.value = 0;
    }

    setTimeout(() => {
      // Clamp to silence and stop old
      gains[oldIdx].gain.value = 0;
      try { oldP.pause(); } catch {}
      oldP.classList.add("hidden");
      newP.classList.remove("hidden");
      activeIdx = newIdx;
      setActive(currentKey);
    }, Math.ceil(sec * 1000));

  }

  // Attach media event instrumentation (both players)
  players.forEach((p) => {
    p.addEventListener("error", () => {
      const msg = describeMediaError(p.error);
      const lastName = (localStorage.getItem(LS_LAST_NAME) || "").trim() || "Audio";
      setNowPlaying(`${lastName} (failed: ${msg})`);
    });
    p.addEventListener("stalled", () => {
      if (p.paused) return;
      const lastName = (localStorage.getItem(LS_LAST_NAME) || "").trim() || "Audio";
      setNowPlaying(`${lastName} (stalled)`);
    });
    p.addEventListener("waiting", () => {
      if (p.paused) return;
      const lastName = (localStorage.getItem(LS_LAST_NAME) || "").trim() || "Audio";
      if (currentKey) setNowPlaying(`${lastName} (bufferingâ€¦)`);
    });
    p.addEventListener("playing", () => {
      const lastName = (localStorage.getItem(LS_LAST_NAME) || "").trim();
      if (lastName) setNowPlaying(lastName);
    });

    p.addEventListener("pause", () => {
      // If user pauses via native controls, reflect that (and avoid misleading "stalled").
      const lastName = (localStorage.getItem(LS_LAST_NAME) || "").trim();
      if (lastName) setNowPlaying(`${lastName} (paused)`);
    });
  });

  // ---- UI Tile builder ----
  function makeTile(item, compact = false) {
    const tile = document.createElement("div");
    tile.className = "tile" + (compact ? " compact-fav" : "");

    // Compact favorites tile
    if (compact) {
      tile.className = "favTile" + (currentKey === item.key ? " active" : "");
      tile.dataset.key = item.key;

      const dot = document.createElement("span");
      dot.className = "colorDot";
      dot.style.backgroundColor = item.color;
      dot.style.color = item.color;

      const name = document.createElement("span");
      name.className = "name";
      name.textContent = item.name;

      tile.appendChild(dot);
      tile.appendChild(name);

      if (item.headphones) {
        const hpIcon = document.createElement("span");
        hpIcon.className = "headphoneIcon";
        hpIcon.textContent = "ðŸŽ§";
        tile.appendChild(hpIcon);
      }

      // Edit-mode action: remove only (no play)
      if (favoritesEditMode) {
        tile.classList.add("editing");

        const actions = document.createElement("span");
        actions.className = "favActions";

        const rm = document.createElement("span");
        rm.className = "miniBtn";
        rm.textContent = "âœ•";
        rm.title = "Remove favorite";
        rm.onclick = (e) => { e.stopPropagation(); toggleFavorite(item.key); };

        actions.appendChild(rm);
        tile.appendChild(actions);
      }

      if (item.url) {
        tile.onclick = () => { if (!favoritesEditMode) playItem(item); };
      }
      return tile;
    }

    // Full tile
    const top = document.createElement("div");
    top.className = "tileTop";

    const dot = document.createElement("span");
    dot.className = "colorDot";
    dot.style.backgroundColor = item.color;
    dot.style.color = item.color;

    const name = document.createElement("span");
    name.className = "name";
    name.textContent = item.name;

    const favBtn = document.createElement("span");
    favBtn.className = "favBtn" + (favorites.includes(item.key) ? " active" : "");
    favBtn.textContent = favorites.includes(item.key) ? "â˜…" : "â˜†";
    favBtn.dataset.key = item.key;
    favBtn.onclick = (e) => {
      e.stopPropagation();
      toggleFavorite(item.key);
    };

    const playBtn = document.createElement("div");
    playBtn.className = "playBtn" + (currentKey === item.key ? " active" : "");
    playBtn.dataset.key = item.key;

    if (item.url) {
      playBtn.textContent = currentKey === item.key ? "Playing" : "Play";
      playBtn.onclick = () => playItem(item);
    } else {
      playBtn.textContent = "Soon";
      playBtn.style.opacity = "0.5";
      playBtn.style.cursor = "default";
    }

    top.appendChild(dot);
    top.appendChild(name);
    top.appendChild(favBtn);
    top.appendChild(playBtn);

    tile.appendChild(top);

    const desc = document.createElement("div");
    desc.className = "desc";
    desc.textContent = item.desc;
    tile.appendChild(desc);

    return tile;
  }

  function renderSection(gridId, sources) {
    const grid = document.getElementById(gridId);
    grid.innerHTML = "";
    sources.forEach(s => grid.appendChild(makeTile(s)));
  }

  function updateLayout() {
    const header = document.querySelector('.fixedHeader');
    const content = document.querySelector('.content');
    const headerHeight = header.offsetHeight;

    if (favoritesSection.classList.contains('hidden')) {
      content.classList.remove('with-favorites');
      content.style.paddingTop = (headerHeight + 16) + 'px';
    } else {
      favoritesSection.style.top = headerHeight + 'px';
      content.classList.add('with-favorites');
      requestAnimationFrame(() => {
        const favHeight = favoritesSection.offsetHeight;
        content.style.paddingTop = (headerHeight + favHeight + 16) + 'px';
      });
    }
  }

  function renderAll() {
    // Favorites
    favGrid.innerHTML = "";
    const favItems = ALL_SOURCES.filter(s => favorites.includes(s.key));

    if (favItems.length > 0) {
      favoritesSection.classList.remove("hidden");
      const favHeader = document.getElementById("favHeader");
      const favEditBtn = document.getElementById("favEditBtn");
      if (favEditBtn) favEditBtn.textContent = favoritesEditMode ? "Done" : "Edit";

      if (!collapsedSections.favorites) {
        favItems.forEach(s => favGrid.appendChild(makeTile(s, true)));
        favGrid.classList.remove("collapsed");
        favHeader.classList.remove("collapsed");
      } else {
        favGrid.classList.add("collapsed");
        favHeader.classList.add("collapsed");
      }
    } else {
      favoritesEditMode = false;
      favoritesSection.classList.add("hidden");
    }

    renderSection("coreGrid", SOURCES_CORE);
    renderSection("blendsGrid", SOURCES_BLENDS);
    renderSection("binauralGrid", SOURCES_BINAURAL);
    renderSection("natureGrid", SOURCES_NATURE);
    renderSection("mechanicalGrid", SOURCES_MECHANICAL);

    // Apply collapsed state
    document.querySelectorAll(".sectionTitle[data-section]").forEach(header => {
      const section = header.dataset.section;
      const grid = header.nextElementSibling;
      if (collapsedSections[section]) {
        header.classList.add("collapsed");
        grid.classList.add("collapsed");
      } else {
        header.classList.remove("collapsed");
        grid.classList.remove("collapsed");
      }
    });

    setActive(currentKey);
    updateLayout();
  }

  // Collapse handlers
  document.querySelectorAll(".sectionTitle[data-section]").forEach(header => {
    header.onclick = () => {
      const section = header.dataset.section;
      collapsedSections[section] = !collapsedSections[section];
      saveCollapsed();
      renderAll();
    };
  });

  // Favorites header and edit toggle
  const favEditBtnEl = document.getElementById("favEditBtn");
  if (favEditBtnEl) {
    favEditBtnEl.onclick = (e) => {
      e.stopPropagation();
      favoritesEditMode = !favoritesEditMode;
      renderAll();
    };
  }
  document.getElementById("favHeader").onclick = () => {
    collapsedSections.favorites = !collapsedSections.favorites;
    saveCollapsed();
    renderAll();
  };

  // ---- Settings drawer wiring ----
  function openSettings() {
    settingsOverlay.classList.remove("hidden");
    settingsOverlay.setAttribute("aria-hidden", "false");
    syncSettingsUI();
  if (IS_IOS) {
    settings.enableCrossfade = false;
    saveSettings();
  }
  }
  
  // Track if settings changes require a reload (deferred until settings panel closes)
  let pendingReload = false;
  
  function closeSettings() {
    settingsOverlay.classList.add("hidden");
    settingsOverlay.setAttribute("aria-hidden", "true");
    
    // If normalization settings changed, reload now
    if (pendingReload) {
      pendingReload = false;
      try { sessionStorage.setItem("colorNoiseDidReloadForNormalize", "1"); } catch {}
      window.location.reload();
    }
  }
  if (settingsBtn) settingsBtn.onclick = () => openSettings();
  if (settingsClose) settingsClose.onclick = () => closeSettings();
  if (settingsOverlay) {
    settingsOverlay.addEventListener("click", (e) => {
      if (e.target === settingsOverlay) closeSettings();
    });
  }
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && !settingsOverlay.classList.contains("hidden")) closeSettings();
  });

  function fmtSec(x) { return `${Number(x).toFixed(Number(x) % 1 === 0 ? 0 : 1)}s`; }
  function fmtPct(x) { return `${Math.round(Number(x) * 100)}%`; }

  function syncSettingsUI() {
    enableCrossfadeEl.checked = !!settings.enableCrossfade;
    crossfadeSecEl.value = settings.crossfadeSec;
    crossfadeSecVal.textContent = fmtSec(settings.crossfadeSec);

    enableFadeOutEl.checked = !!settings.enableFadeOut;
    fadeOutSecEl.value = settings.fadeOutSec;
    fadeOutSecVal.textContent = fmtSec(settings.fadeOutSec);

    masterVolEl.value = settings.masterVol;
    masterVolVal.textContent = fmtPct(settings.masterVol);
    if (mainMasterVolEl) mainMasterVolEl.value = settings.masterVol;
    if (mainMasterVolVal) mainMasterVolVal.textContent = fmtPct(settings.masterVol);

    if (showSleepTimerEl) showSleepTimerEl.checked = !!settings.showSleepTimer;

    if (showMainVolumeEl) showMainVolumeEl.checked = !!settings.showMainVolume;
    if (enableNormalizeEl) enableNormalizeEl.checked = !!settings.enableNormalize;
    if (showPerTrackPanelEl) showPerTrackPanelEl.checked = !!settings.showPerTrackPanel;
  }

  function applyMasterVol() {
    // WebAudio path (desktop)
    if (masterGain) masterGain.gain.value = settings.masterVol;
    
    // iOS path: update active player's volume directly
    if (IS_IOS && currentKey) {
      applyPerTrackToElement(activePlayer(), currentKey);
    }
  }

  function applySleepTimerVisibility() {
    const timerRow = document.querySelector(".timerRow");
    if (!timerRow) return;
    if (settings.showSleepTimer) timerRow.classList.remove("hidden");
    else timerRow.classList.add("hidden");
    updateLayout();
  }


  function applyMainVolumeVisibility() {
    if (!mainVolRow) return;
    // iOS doesn't support programmatic volume control (audio.volume is read-only)
    // so hide the volume slider on iOS
    if (IS_IOS) {
      mainVolRow.classList.add("hidden");
      return;
    }
    if (settings.showMainVolume) mainVolRow.classList.remove("hidden");
    else mainVolRow.classList.add("hidden");
    updateLayout();
  }


  function applyPerTrackVisibility() {
    if (!perTrackRow) return;
    // iOS doesn't support programmatic volume control (audio.volume is read-only)
    // so hide per-track adjustments on iOS
    if (IS_IOS) {
      perTrackRow.classList.add("hidden");
      return;
    }
    // On desktop, per-track adjustments require the WebAudio normalization graph
    const shouldShow = !!settings.enableNormalize && !!settings.showPerTrackPanel && !!currentKey;
    if (shouldShow) perTrackRow.classList.remove("hidden");
    else perTrackRow.classList.add("hidden");
    updateLayout();
  }

  enableCrossfadeEl.onchange = () => {
    settings.enableCrossfade = enableCrossfadeEl.checked;
    saveSettings();
  };
  crossfadeSecEl.oninput = () => {
    settings.crossfadeSec = Number(crossfadeSecEl.value);
    crossfadeSecVal.textContent = fmtSec(settings.crossfadeSec);
    saveSettings();
  };
  enableFadeOutEl.onchange = () => {
    settings.enableFadeOut = enableFadeOutEl.checked;
    saveSettings();
  };
  fadeOutSecEl.oninput = () => {
    settings.fadeOutSec = Number(fadeOutSecEl.value);
    fadeOutSecVal.textContent = fmtSec(settings.fadeOutSec);
    saveSettings();
  };

  if (showMainVolumeEl) {
    showMainVolumeEl.onchange = () => {
      settings.showMainVolume = showMainVolumeEl.checked;
      saveSettings();
      applyMainVolumeVisibility();
  applyPerTrackVisibility();
    };
  }
  
  const reloadIndicator = document.getElementById("reloadIndicator");
  function updateReloadIndicator() {
    if (reloadIndicator) {
      if (pendingReload) reloadIndicator.classList.remove("hidden");
      else reloadIndicator.classList.add("hidden");
    }
  }
  
  if (showPerTrackPanelEl) {
    showPerTrackPanelEl.onchange = () => {
      settings.showPerTrackPanel = showPerTrackPanelEl.checked;
      
      // If enabling sound-specific controls, also enable normalization
      if (settings.showPerTrackPanel && !settings.enableNormalize) {
        settings.enableNormalize = true;
        if (enableNormalizeEl) enableNormalizeEl.checked = true;
        // Normalization change requires reload (deferred to settings close)
        pendingReload = true;
        updateReloadIndicator();
      }
      
      saveSettings();
      applyPerTrackVisibility();
    };
  }

  if (enableNormalizeEl) {
    enableNormalizeEl.onchange = async () => {
      settings.enableNormalize = enableNormalizeEl.checked;
      
      // If disabling normalization, also disable sound-specific controls (they're useless without it)
      if (!settings.enableNormalize && settings.showPerTrackPanel) {
        settings.showPerTrackPanel = false;
        if (showPerTrackPanelEl) showPerTrackPanelEl.checked = false;
      }
      
      saveSettings();
      applyPerTrackVisibility();

      // Changing normalization re-wires the WebAudio graph; reload deferred to settings close
      pendingReload = true;
      updateReloadIndicator();
    };
  }

  if (showSleepTimerEl) {
    showSleepTimerEl.onchange = () => {
      settings.showSleepTimer = showSleepTimerEl.checked;
      saveSettings();
      applySleepTimerVisibility();
    };
  }

  if (mainMasterVolEl) {
    mainMasterVolEl.oninput = () => {
      settings.masterVol = Number(mainMasterVolEl.value);
      if (mainMasterVolVal) mainMasterVolVal.textContent = fmtPct(settings.masterVol);
      if (masterVolEl) masterVolEl.value = settings.masterVol;
      if (masterVolVal) masterVolVal.textContent = fmtPct(settings.masterVol);
      saveSettings();
      applyMasterVol();
    };
  }

  function refreshTrimUI() {
    if (!mainTrimValEl) return;
    const db = getTrimDb(currentKey);
    mainTrimValEl.textContent = `${db.toFixed(0)} dB`;
  }

  function applyCurrentTrimToActive() {
    if (IS_IOS) {
      if (!currentKey) return;
      applyPerTrackToElement(activePlayer(), currentKey);
      return;
    }

    if (!settings.enableNormalize) return;
    if (!currentKey) return;
    if (!activePlayer().paused && trimGains && trimGains[activeIdx]) {
      trimGains[activeIdx].gain.value = dbToGain(getTrimDb(currentKey));
    }
  }

  if (mainTrimDownEl) mainTrimDownEl.onclick = () => {
    if (!currentKey) return;
    setTrimDb(currentKey, getTrimDb(currentKey) - 1);
    applyCurrentTrimToActive();
    refreshTrimUI();
  };

  if (mainTrimUpEl) mainTrimUpEl.onclick = () => {
    if (!currentKey) return;
    setTrimDb(currentKey, getTrimDb(currentKey) + 1);
    applyCurrentTrimToActive();
    refreshTrimUI();
  };

  if (mainTrimResetEl) mainTrimResetEl.onclick = () => {
    if (!currentKey) return;
    setTrimDb(currentKey, 0);
    applyCurrentTrimToActive();
    refreshTrimUI();
  };

  masterVolEl.oninput = () => {
    settings.masterVol = Number(masterVolEl.value);
    masterVolVal.textContent = fmtPct(settings.masterVol);
    if (mainMasterVolEl) mainMasterVolEl.value = settings.masterVol;
    if (mainMasterVolVal) mainMasterVolVal.textContent = fmtPct(settings.masterVol);
    saveSettings();
    applyMasterVol();
  };

  // ---- Sleep timer logic (with optional fade-out) ----
  let setHours = 0;
  let setMins = 0;
  let endTime = null;
  let timerInterval = null;

  function formatTime(ms) {
    if (ms <= 0) return "0:00";
    const totalSec = Math.ceil(ms / 1000);
    const h = Math.floor(totalSec / 3600);
    const m = Math.floor((totalSec % 3600) / 60);
    const s = totalSec % 60;
    if (h > 0) return h + ":" + String(m).padStart(2, "0") + ":" + String(s).padStart(2, "0");
    return m + ":" + String(s).padStart(2, "0");
  }

  function updateSetDurationPreview() {
    if (endTime) return;
    const totalMs = (setHours * 3600 + setMins * 60) * 1000;
    if (totalMs <= 0) {
      timerDisplay.textContent = "0:00";
      timerDisplay.classList.add("off");
      return;
    }
    timerDisplay.textContent = formatTime(totalMs);
    timerDisplay.classList.add("off");
  }

  function updateTimerDisplay() {
    if (!endTime) {
      updateSetDurationPreview();
      return;
    }
    const remaining = endTime - Date.now();
    if (remaining <= 0) {
      stopTimer(true);
      return;
    }
    timerDisplay.textContent = formatTime(remaining);
    timerDisplay.classList.remove("off");
  }

  function startTimer() {
    const totalMs = (setHours * 3600 + setMins * 60) * 1000;
    if (totalMs <= 0) return;

    endTime = Date.now() + totalMs;
    toggleTimerBtn.textContent = "Stop";
    timerDisplay.classList.remove("off");

    updateTimerDisplay();
    timerInterval = setInterval(updateTimerDisplay, 1000);
  }

  async function stopTimer(finished = false) {
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }

    if (finished) {
      if (currentKey) {
        if (settings.enableFadeOut && settings.fadeOutSec > 0) {
          await stopPlayback("Timer finished", true);
        } else {
          await stopPlayback("Timer finished", false);
        }
      } else {
        setNowPlaying("Timer finished");
      }
    }

    endTime = null;
    toggleTimerBtn.textContent = "Start";
    updateSetDurationPreview();
  }

  toggleTimerBtn.onclick = () => {
    if (endTime) stopTimer(false);
    else startTimer();
  };

  document.getElementById("hMinus").onclick = () => { setHours = Math.max(0, setHours - 1); hoursEl.textContent = setHours; updateSetDurationPreview(); };
  document.getElementById("hPlus").onclick = () => { setHours = Math.min(12, setHours + 1); hoursEl.textContent = setHours; updateSetDurationPreview(); };
  document.getElementById("mMinus").onclick = () => { setMins = setMins - 15; if (setMins < 0) setMins = 45; minsEl.textContent = setMins; updateSetDurationPreview(); };
  document.getElementById("mPlus").onclick = () => { setMins = setMins + 15; if (setMins > 45) setMins = 0; minsEl.textContent = setMins; updateSetDurationPreview(); };

  // Initialize timer preview
  updateSetDurationPreview();

  // Restore last selection (do not autoplay)
  (function restoreLastSelection() {
    // Always start neutral on reload.
    currentKey = null;
    setActive(null);
    setNowPlaying("Select a sound below");
  })();

  // Initial render
  try { sessionStorage.removeItem("colorNoiseDidReloadForNormalize"); } catch {}
  renderAll();
  applySleepTimerVisibility();
  applyMainVolumeVisibility();

  // Disable volume-related settings on iOS (audio.volume is read-only on iOS)
  if (IS_IOS) {
    const disableRows = ['masterVolRow', 'showMainVolumeRow', 'normalizeRow', 'showPerTrackRow'];
    const showNotes = ['masterVolIosNote', 'showMainVolumeIosNote', 'normalizeIosNote', 'showPerTrackIosNote'];
    
    disableRows.forEach(id => {
      const row = document.getElementById(id);
      if (row) row.classList.add('disabled');
    });
    
    showNotes.forEach(id => {
      const note = document.getElementById(id);
      if (note) note.classList.remove('hidden');
    });
  }

  // Fix initial layout (fonts/audio controls can change header height after first paint)
  window.addEventListener("load", () => updateLayout());
  setTimeout(() => updateLayout(), 250);
  setTimeout(() => updateLayout(), 1000);

  // Check sound engine status (Internet Archive) â€” reliable media probe
  (function checkArchiveStatus() {
    const statusEl = document.getElementById("sourceStatus");
    const testUrl = "https://archive.org/download/1-hour-brown-noise-and-flowing-water-320/1%20hour%20Brown%20Noise%20and%20Flowing%20River%20flac.mp3";

    const probe = new Audio();
    probe.preload = "metadata";
    probe.crossOrigin = "anonymous";

    const set = (state, text) => {
      statusEl.innerHTML = `<span class="dot ${state}"></span>${text}`;
    };

    set("checking", "Sound engine: checkingâ€¦");

    let done = false;
    const finish = (ok) => {
      if (done) return;
      done = true;
      try { probe.src = ""; } catch {}
      if (ok) set("up", "Sound engine: operational");
      else set("down", "Sound engine: offline (Internet Archive appears down)");
    };

    const t = setTimeout(() => finish(false), 8000);
    probe.addEventListener("canplaythrough", () => { clearTimeout(t); finish(true); }, { once: true });
    probe.addEventListener("loadedmetadata", () => { clearTimeout(t); finish(true); }, { once: true });
    probe.addEventListener("error", () => { clearTimeout(t); finish(false); }, { once: true });

    probe.src = testUrl;
    probe.load();
  })();

  // Keep layout correct on resize/orientation change
  window.addEventListener("resize", () => updateLayout());

})();
</script>
</body>
</html>
